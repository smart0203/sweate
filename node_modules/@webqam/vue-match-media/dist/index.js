"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
function isNumberWithUnit(v) {
    return typeof v === 'string' && !!v.match(/^\d+(?:r?em|px)$/);
}
function valueWithUnit(v) {
    if ((typeof v === 'number' && !isNaN(v)) ||
        (typeof v === 'string' && v.match(/^\d+(?:\.\d+)?$/))) {
        return v + "px";
    }
    else if (typeof v === 'string') {
        return v;
    }
    throw new TypeError('Unknown unit value.');
}
function pascalToKebab(str) {
    return str.replace(/[\w]([A-Z])/g, function (m) { return m[0] + '-' + m[1]; }).toLowerCase();
}
function populateRules(breakpoint) {
    var rules = {};
    if (typeof breakpoint === 'number' || isNumberWithUnit(breakpoint)) {
        rules.minWidth = breakpoint;
    }
    else if (breakpoint instanceof Array &&
        breakpoint.length === 2) {
        var _a = breakpoint, minWidth = _a[0], maxWidth = _a[1];
        if (typeof minWidth === 'number' || isNumberWithUnit(minWidth)) {
            rules.minWidth = minWidth;
        }
        if (typeof maxWidth === 'number' || isNumberWithUnit(maxWidth)) {
            rules.maxWidth = maxWidth;
        }
    }
    else if (typeof breakpoint === 'object') {
        rules = __assign(__assign({}, rules), breakpoint);
    }
    return rules;
}
exports.default = {
    install: function (Vue, _a) {
        var _b = (_a === void 0 ? {} : _a).breakpoints, breakpoints = _b === void 0 ? {} : _b;
        var keys = Object.keys(breakpoints);
        var computedBreakpoints = keys.reduce(function (acc, k) {
            var rules = populateRules((typeof breakpoints[k] === 'object' &&
                breakpoints[k].breakpoint) ||
                breakpoints[k]);
            acc[k] = Object.keys(rules)
                .map(function (r) { return "(" + pascalToKebab(r) + ": " + valueWithUnit(rules[r]) + ")"; })
                .join(' and ');
            return acc;
        }, {});
        var matchmediaObservable = Vue.observable(keys.reduce(function (acc, k) {
            // SSR
            if (typeof window === 'undefined') {
                if (typeof breakpoints[k].defaultValue ===
                    'undefined') {
                    throw new Error("In order to use this plugin with SSR, you must provide a default value for every breakpoint (defaultValue is missing for breakpoint '" + k + "')");
                }
                acc[k] =
                    breakpoints[k].defaultValue || false;
            }
            // Client
            else {
                var mq = window.matchMedia(computedBreakpoints[k]);
                // Using the deprecated addListener instead of addEventListener
                // due to the lack of support in Safari
                mq.addListener(function (e) {
                    matchmediaObservable[k] = e.matches;
                });
                acc[k] = mq.matches;
            }
            return acc;
        }, {}));
        Vue.prototype.$matchMedia = matchmediaObservable;
    },
};
